---
description: 代碼質量與最佳實踐（整合自 awesome-cursorrules）
alwaysApply: true
---

# 代碼質量原則（強制）

## 核心原則

### 1. 驗證與證據優先
- **驗證信息**：在呈現結論前驗證信息，不假設或推測
- **證據優先**：任何推論必須指出依據（字串、CFG、syscall、maps、stack trace、binder 代碼、JNI RegisterNatives 等）
- **可重現性**：任何實驗必須提供可重現的步驟和觀測點

### 2. 簡潔性與可讀性
- **簡潔性**：寫簡單直接的代碼，避免不必要的複雜度
- **可讀性**：確保代碼易讀易懂，優先考慮可讀性而非過度優化
- **最小變更**：只修改與任務相關的代碼部分，避免修改無關代碼
- **避免清理**：除非明確要求，否則不進行代碼清理或重構

### 3. 描述性命名
- **函數命名**：動詞開頭，描述意圖 + 作用域
  - ✅ 正確：`validateInstallerSource()`, `scanProcMapsForHooks()`, `verifyTextSegmentCrc()`
  - ❌ 錯誤：`check()`, `scan()`, `verify()`
- **變數命名**：資料型態 + 角色
  - ✅ 正確：`mapsFd`, `textBase`, `crcExpected`, `jniEnv`, `regNativesTable`
  - ❌ 錯誤：`fd`, `base`, `crc`, `env`, `table`
- **事件處理器**：前綴 `handle`（如 `handleClick`, `handleKeyDown`）

### 4. 錯誤處理與邊界情況
- **穩健的錯誤處理**：實現穩健的錯誤處理和日誌記錄
- **邊界情況**：考慮並處理潛在的邊界情況
- **異常處理**：優雅地處理異常（try-except/try-catch）
- **防呆機制**：任何 hook 請自帶防呆（null 檢查、pointer validity、try/catch 包裹）

### 5. 模組化與可重用性
- **模組化設計**：鼓勵模組化設計以提高可維護性和可重用性
- **DRY 原則**：避免重複代碼（Don't Repeat Yourself）
- **函數順序**：組合其他函數的函數應出現在文件較早位置
- **可測試性**：確保代碼易於測試

### 6. 性能考量
- **性能意識**：保持性能意識，但不過度優化而犧牲可讀性
- **避免熱路徑日誌**：避免在 hot path 大量 console.log（改用 ring buffer 或採樣）
- **早期返回**：使用早期返回避免嵌套條件，提高可讀性

---

# 代碼風格規範

## JavaScript/TypeScript（Frida 腳本）

### 基本原則
- **早期返回**：使用早期返回避免嵌套條件
- **條件類別**：對於類別屬性，優先使用條件類別而非三元運算符
- **常數優先**：使用常數而非函數（如適用，定義類型）
- **函數式風格**：優先使用函數式、不可變風格，除非變得過於冗長

### 註釋與文檔
- **函數註釋**：在每個函數開始處添加註釋，描述其功能
- **JSDoc 註釋**：對 JavaScript（除非是 TypeScript）使用 JSDoc 註釋和現代 ES6 語法
- **TODO 註釋**：如果遇到現有代碼中的 bug，或指令導致次優或錯誤的代碼，添加以 "TODO:" 開頭的註釋，概述問題

### 代碼組織
- **函數順序**：組合其他函數的函數應出現在文件較早位置
- **單一職責**：每個函數應有單一明確的職責
- **最小代碼變更**：只修改與任務相關的代碼部分

## Python（分析腳本）

### 基本原則
- **PEP 8 風格**：遵循 PEP 8 風格指南進行格式化
- **文檔字符串**：使用 docstrings 記錄函數和類
- **類型提示**：使用類型提示提高代碼清晰度和類型檢查
- **列表推導**：在適當情況下使用列表推導創建列表
- **異常處理**：使用 try-except 塊優雅地處理異常
- **全局變數**：限制全局變數的使用以減少副作用

### 命名規範
- **描述性名稱**：選擇描述性的變數、函數和類名
- **避免魔法數字**：用命名常數替換硬編碼值，提高代碼清晰度和可維護性

---

# 逆向工程特定規範

## 證據收集
- **必須記錄**：函數調用的參數值、返回值、線程 ID、調用時機
- **堆疊追蹤**：使用 Backtracer.ACCURATE（能用就用），不行再 FALLBACK
- **記錄格式**：每條 log 含：時間、tid、module!symbol/offset、args、ret

## 版本管理
- **版本標註**：所有代碼、腳本、報告必須標註適用的 App 版本
- **版本檢查**：開始分析前，必須確認當前分析的 App 版本
- **版本信息來源**：`config/VERSION_INFO.md`

## 安全與合規
- **合規邊界**：只提供合法研究與防禦/測試用途的建議與內容
- **不提供攻擊腳本**：不輸出可直接用於未授權繞過的完整攻擊腳本
- **替代方案**：若需求落在高風險區域，改以「偵測、可觀測性、風險評估、除錯與硬化」的替代方案

---

# 禁止事項

## 代碼變更
- ❌ 不要移除無關代碼或功能
- ❌ 不要修改現有註釋（除非明確要求）
- ❌ 不要進行任何清理（除非明確要求）
- ❌ 不要建議空白字符變更
- ❌ 不要發明未明確請求的變更

## 溝通方式
- ❌ 不要使用道歉
- ❌ 不要在註釋或文檔中提供理解反饋
- ❌ 不要總結已做的變更
- ❌ 不要要求確認上下文中已提供的信息
- ❌ 不要要求驗證上下文中可見的實現

## 實現方式
- ❌ 不要顯示或討論當前實現（除非明確要求）
- ❌ 不要提供多步驟指令或同一文件的解釋
- ❌ 不要建議更新或變更沒有實際修改需要的文件

---

# 最佳實踐檢查清單

## 編寫代碼前
- [ ] 確認問題定義清楚
- [ ] 確認 App 版本信息正確
- [ ] 確認需要修改的範圍

## 編寫代碼時
- [ ] 使用描述性命名
- [ ] 添加適當的錯誤處理
- [ ] 考慮邊界情況
- [ ] 添加必要的註釋
- [ ] 保持代碼簡潔

## 編寫代碼後
- [ ] 驗證代碼符合項目風格
- [ ] 確認錯誤處理完整
- [ ] 確認版本信息已標註
- [ ] 確認合規邊界未違反
